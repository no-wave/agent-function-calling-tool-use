# AI 에이전트 프로토콜의 삼각구도: MCP, ACP, A2A 상세 분석

인공지능 에이전트 생태계에서 상호 운용성과 협업을 위한 세 가지 핵심 프로토콜이 등장하여 각각 고유한 역할을 담당하고 있다. **Model Context Protocol (MCP), Agent Communication Protocol (ACP), Agent-to-Agent Protocol (A2A)**는 서로 다른 접근 방식과 설계 철학을 통해 AI 에이전트 시대의 기반 인프라를 구축하고 있다. 이들 프로토콜은 각각 Anthropic, Linux Foundation, Google이라는 서로 다른 주체에 의해 개발되어 독특한 특징과 장점을 보여주며, 동시에 상호 보완적인 관계를 형성하고 있다.

## MCP: 에이전트 컨텍스트의 무한 확장

Model Context Protocol (MCP)는 2024년 11월 Anthropic이 발표한 혁신적인 프로토콜로, AI 에이전트와 외부 데이터 소스 간의 연결을 표준화하는 "AI를 위한 USB-C"라고 불린다. MCP의 핵심 목적은 AI 모델들이 정보 사일로와 레거시 시스템에 갇혀 있던 문제를 해결하고, 각 데이터 소스마다 개별 통합이 필요했던 N×M 문제를 N+M 문제로 변환하여 개발 효율성을 획기적으로 향상시키는 것이다.

MCP는 에이전트의 컨텍스트를 풍부하게 만들기 위해 세 가지 핵심 구성 요소를 제공한다. **Tools(도구)**는 모델이 제어하는 함수들로, API 호출이나 데이터베이스 쿼리 같은 특정 작업을 수행할 수 있게 해준다. **Resources(리소스)**는 애플리케이션이 제어하는 데이터 소스로, 파일 내용이나 문서 저장소 같은 정보에 부작용 없이 접근할 수 있도록 한다. **Prompts(프롬프트)**는 사용자가 제어하는 재사용 가능한 템플릿으로, 특정 워크플로우나 작업 패턴을 일관되게 수행할 수 있게 해준다.

기술적으로 MCP는 JSON-RPC 2.0을 기반으로 하는 클라이언트-서버 아키텍처를 채택하고 있다. MCP Host는 사용자가 상호작용하는 애플리케이션이며, MCP Client는 Host 내에서 특정 서버와 1:1 연결을 관리한다. MCP Server는 경량 프로그램으로 특정 기능을 노출하며, 다양한 전송 메커니즘을 지원한다. Stdio Transport는 로컬 프로세스 간 통신에 사용되고, HTTP/SSE Transport는 원격 서버와의 통신에 활용된다.

현재 MCP는 놀라운 속도로 확산되고 있다. OpenAI가 2025년 3월 Agents SDK에서 MCP 지원을 추가했고, Google DeepMind도 2025년 4월 Gemini 모델에서 MCP 지원을 확정했다. Microsoft는 공식 C# SDK 개발에 협력하고 있으며, 2025년 2월 기준으로 1,000개 이상의 MCP 서버가 구축되어 활발한 생태계를 형성하고 있다.

## ACP: 오픈 거버넌스 기반의 에이전트 통신

Agent Communication Protocol (ACP)는 Linux Foundation AI & Data 프로그램 하에서 관리되는 오픈 표준 프로토콜로, 서로 다른 프레임워크와 환경에서 실행되는 AI 에이전트들 간의 상호 운용성을 제공한다. 2025년 4월 IBM이 BeeAI 프로젝트와 함께 Linux Foundation에 기부했으며, 투명하고 커뮤니티 주도적인 거버넌스 구조를 통해 발전하고 있다.

ACP가 REST 방식을 채택한 이유는 단순성과 생산성에 있다. 표준 HTTP 패턴을 사용하여 curl, Postman, 브라우저 등 익숙한 도구로 직접 상호작용할 수 있으며, 특별한 SDK 없이도 사용이 가능하다. 모든 유효한 MIME 타입을 지원하여 높은 확장성을 제공하고, 멀티파트 메시지를 통해 텍스트, 이미지, JSON 데이터 등을 하나의 메시지에 포함할 수 있다.

ACP는 다중 에이전트/서버 지원 아키텍처를 통해 뛰어난 확장성을 제공한다. 단일 에이전트 아키텍처부터 분산 멀티 서버까지 다양한 구성을 지원하며, 각 서버의 독립적 스케일링과 장애 격리를 가능하게 한다. 서로 다른 에이전트 유형의 독립적 스케일링과 복잡한 요청을 전문화된 하위 작업으로 분해하는 라우터 패턴을 지원한다.

세션 상태 관리에서 ACP는 중앙 저장소 접근 방식을 사용한다. 요청에 session_id가 없으면 서버가 자동으로 생성하며, ACP SDK의 session() 컨텍스트 관리자를 통해 편리한 세션 상태 유지가 가능하다. 같은 session_id를 사용하는 모든 실행에서 전체 대화 히스토리에 접근할 수 있어 멀티턴 상태를 여러 에이전트 실행에 걸쳐 보존한다.

아티팩트 및 히스토리 관리에서 ACP는 통합된 접근 방식을 취한다. 에이전트가 배포 패키지에 직접 메타데이터를 임베드하여 비활성 상태에서도 발견이 가능하며, 보안이 중요하거나 연결이 끊어진 환경에서도 작동한다. 각 실행의 run_id와 session_id를 통한 추적 가능성을 제공하고, 전체 세션 히스토리를 입력 인수에 포함하여 컨텍스트를 보존한다.

## A2A: Google의 분산형 에이전트 협업 비전

Agent-to-Agent Protocol (A2A)는 Google이 2025년 4월 Google Cloud Next에서 발표한 오픈 프로토콜로, 대규모 다중 에이전트 시스템의 상호 운용성 문제를 해결하기 위해 개발되었다. Google은 50개 이상의 기술 파트너와 협력하여 A2A를 개발했으며, Apache License 2.0 하에서 오픈소스로 공개했다.

A2A는 JSON-RPC 2.0을 채택한 이유로 기존 웹 표준의 활용을 들고 있다. 이미 널리 사용되고 검증된 프로토콜을 재사용하여 개발자 마찰을 최소화하고, 상태 비저장 원격 프로시저 호출을 통해 경량성을 확보했다. HTTP, 소켓, 메시지 전달 등 다양한 전송 방식을 지원하며, 표준화된 에러 코드와 구조를 제공한다.

A2A의 1 에이전트/서버 구조는 명확한 클라이언트-서버 아키텍처를 기반으로 한다. A2A Client는 요청을 시작하는 에이전트이며, A2A Server는 HTTP 엔드포인트를 노출하는 원격 에이전트다. 이 구조는 불투명한 실행(Opaque Execution)을 핵심 특징으로 하여, 에이전트들이 내부 상태나 메모리를 노출하지 않고도 협업할 수 있게 한다.

에이전트가 선택하는 세션 상태 관리는 A2A의 독특한 특징이다. Context ID를 통해 관련된 여러 작업들을 논리적으로 그룹화하고, 완료된 작업은 불변으로 처리한다. 각 에이전트가 독립적으로 내부 상태를 관리하면서 필요한 컨텍스트만 공유하는 분산 상태 관리 방식을 채택했다. 이는 확장성과 장애 격리, 보안 측면에서 장점을 제공하지만, 시스템 복잡성 증가와 디버깅의 어려움이라는 단점도 수반한다.

분리된 아티팩트 및 히스토리 관리에서 A2A는 불변성을 핵심으로 한다. 생성된 아티팩트는 변경이 불가하며, 컨텍스트 태깅을 통해 생성 출처와 처리 에이전트 정보를 포함한다. 다차원적 대화 히스토리 표현을 통해 선형 기록이 아닌 복잡한 협업 패턴을 추적하며, 선택적 노출을 통해 관련된 컨텍스트 세그먼트만 공유한다.

## MCP → ACP 연동: 컨텍스트 확장에서 협업으로

MCP와 ACP의 연동은 AI 에이전트가 더 강력한 능력을 발휘할 수 있게 하는 핵심 메커니즘이다. 에이전트는 먼저 MCP를 통해 다양한 도구, 리소스, 프롬프트에 접근하여 컨텍스트를 풍부하게 만든다. 예를 들어, 특정 에이전트가 GitHub MCP 서버를 통해 프로젝트 정보를 수집하고, 데이터베이스 MCP 서버를 통해 관련 데이터를 조회한 후, 이 정보를 바탕으로 복잡한 분석이 필요하다고 판단할 수 있다.

이때 ACP가 등장한다. 해당 에이전트는 ACP를 통해 데이터 분석 전문 에이전트에게 작업을 요청하거나, 보고서 작성 전문 에이전트와 협업할 수 있다. MCP로 획득한 풍부한 컨텍스트는 ACP의 멀티파트 메시지 기능을 통해 다른 에이전트들에게 효과적으로 전달되며, ACP의 세션 관리 기능을 통해 여러 에이전트 간의 협업 상태가 유지된다.

이러한 연동 시나리오에서 MCP는 "정보 수집과 도구 활용"의 역할을 담당하고, ACP는 "에이전트 간 협업과 워크플로우 관리"의 역할을 수행한다. 두 프로토콜의 조합은 단일 에이전트의 한계를 넘어선 복잡하고 전문화된 작업의 수행을 가능하게 한다.

## ACP vs A2A: 같은 목표, 다른 철학

ACP와 A2A는 모두 에이전트 간 통신을 표준화한다는 동일한 목표를 갖고 있지만, 거버넌스와 아키텍처 선택에서 근본적인 차이를 보인다. 가장 중요한 차이점은 거버넌스 구조다. ACP는 Linux Foundation이라는 중립적인 오픈소스 재단에서 관리되어 벤더 독립성을 보장하는 반면, A2A는 Google이 주도하면서도 오픈소스로 공개하여 Google Cloud 생태계와의 깊은 통합을 추구한다.

통신 방식에서도 뚜렷한 차이를 보인다. ACP는 네이티브 REST API를 채택하여 HTTP의 GET, POST, DELETE 등 표준 메서드를 직접 활용하며, curl이나 브라우저 같은 일반적인 도구로도 테스트할 수 있다. 반면 A2A는 JSON-RPC 2.0 over HTTP를 사용하여 더 구조화된 원격 프로시저 호출 방식을 제공한다. 이는 ACP가 웹 개발자들에게 더 친숙한 반면, A2A는 더 정교한 프로토콜 설계를 제공한다는 차이를 만든다.

아키텍처 접근 방식에서도 대조적이다. ACP는 다중 에이전트/서버 지원을 통해 하나의 HTTP 엔드포인트 뒤에 여러 에이전트를 호스팅할 수 있으며, 중앙 집중식 관리가 가능하다. A2A는 1 에이전트/서버 구조를 통해 각 에이전트의 독립성을 강조하며, 불투명한 실행을 통해 보안성을 높인다.

세션 상태 관리에서도 철학적 차이가 나타난다. ACP는 중앙 저장소를 통한 통합된 세션 관리를 제공하여 일관성을 보장하는 반면, A2A는 각 에이전트가 선택하는 분산 상태 관리를 통해 확장성과 독립성을 추구한다. 아티팩트와 히스토리 관리에서도 ACP는 통합된 관리 시스템을, A2A는 분리된 관리 시스템을 채택하여 서로 다른 장단점을 제공한다.

발견 메커니즘에서도 차이를 보인다. ACP는 메타데이터 임베딩을 통해 에이전트가 비활성 상태에서도 발견될 수 있게 하며, 이는 보안이 중요한 환경이나 scale-to-zero 환경에서 유용하다. A2A는 Agent Cards를 통한 발견 메커니즘을 제공하여 더 동적인 에이전트 등록과 검색을 지원한다.

## 프로토콜 간 상호작용과 미래 전망

세 프로토콜은 경쟁 관계가 아닌 상호 보완적 관계를 형성하고 있다. MCP는 에이전트가 외부 세계와 연결되는 방법을 표준화하고, ACP와 A2A는 에이전트들이 서로 협업하는 방법을 각각 다른 철학으로 제공한다. 실제 기업 환경에서는 이 세 프로토콜이 함께 사용될 가능성이 높다.

예를 들어, 한 조직에서 운영하는 AI 에이전트 시스템은 MCP를 통해 내부 데이터베이스, 문서 시스템, API 등에 연결될 수 있다. 동시에 Linux Foundation의 중립성을 선호하는 부서는 ACP를 통해 에이전트 간 협업을 구현하고, Google Cloud를 사용하는 다른 부서는 A2A를 활용할 수 있다. MCP의 표준화된 컨텍스트 확장 기능은 두 협업 프로토콜 모두와 잘 어우러진다.

향후 발전 방향을 보면, MCP는 보안 강화와 생태계 확장에 주력하고 있으며, OpenAI와 Google의 채택으로 사실상의 표준으로 자리잡을 것으로 예상된다. ACP는 Linux Foundation의 강력한 오픈소스 생태계를 바탕으로 벤더 중립적인 솔루션을 추구하며, 특히 오픈소스를 선호하는 기업들에게 어필할 것이다. A2A는 Google Cloud 생태계와의 깊은 통합을 통해 엔터프라이즈 시장에서 강력한 위치를 차지할 것으로 보인다.

결론적으로, 이 세 프로토콜은 AI 에이전트 시대의 핵심 인프라를 구성하는 서로 다른 층위의 표준들이다. MCP는 에이전트의 능력을 확장하는 기반 레이어를, ACP와 A2A는 에이전트 간 협업을 가능하게 하는 통신 레이어를 제공하여, 함께 더욱 지능적이고 협업적인 AI 시스템의 구현을 가능하게 하고 있다.